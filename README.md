# `coqffi`

[![Travis][travis-shield]][travis-link]
[![Contributing][contributing-shield]][contributing-link]
[![Code of Conduct][conduct-shield]][conduct-link]
[![Zulip][zulip-shield]][zulip-link]

[travis-shield]: https://travis-ci.com/coq-community/coqffi.svg?branch=master
[travis-link]: https://travis-ci.com/coq-community/coqffi/builds

[contributing-shield]: https://img.shields.io/badge/contributions-welcome-%23f7931e.svg
[contributing-link]: https://github.com/coq-community/manifesto/blob/master/CONTRIBUTING.md

[conduct-shield]: https://img.shields.io/badge/%E2%9D%A4-code%20of%20conduct-%23f15a24.svg
[conduct-link]: https://github.com/coq-community/manifesto/blob/master/CODE_OF_CONDUCT.md

[zulip-shield]: https://img.shields.io/badge/chat-on%20zulip-%23c1272d.svg
[zulip-link]: https://coq.zulipchat.com/#narrow/stream/237663-coq-community-devs.20.26.20users



`coqffi` generates the necessary Coq boilerplate to use OCaml functions in a
Coq development, and configures the Coq extraction mechanism accordingly.

## Meta

- Author(s):
  - Thomas Letan
  - Li-yao Xia
  - Yann RÃ©gis-Gianas
  - Yannick Zakowski
- Coq-community maintainer(s):
  - Thomas Letan ([**@lthms**](https://github.com/lthms))
- License: [MIT License](LICENSE)
- Compatible Coq versions: 8.12 or later
- Compatible OCaml versions: 4.10
- Additional dependencies:
  - [coq-ext-lib](https://github.com/coq-community/coq-ext-lib) 0.11.2 or later
  - [Coq Simple IO](https://github.com/Lysxia/coq-simple-io) 1.3.0 or later
  - [Cmdliner](http://erratique.ch/software/cmdliner) 1.0.4 or later
  - [Dune](https://dune.build) 2.5 or later
- Coq namespace: `CoqFFI`
- Related publication(s): none

## Building and installation instructions

 ``` shell
 git clone https://github.com/coq-community/coqffi.git
 cd coqffi
 dune build -p coq-coqffi
 dune install
 ```

## Example

Suppose the following OCaml header file (`file.mli`) is given:

```ocaml
open Coqbase

type fd

val fd_equal : fd -> fd -> bool

val openfile : Bytestring.t -> fd [@@impure]
val read_all : fd -> Bytestring.t [@@impure]
val write : fd -> Bytestring.t -> unit [@@impure]
val closefile : fd -> unit [@@impure]
```

`coqffi` then generates the necessary Coq boilerplate to use these
functions in a Coq development:

```coq
(* This file has been generated by coqffi. *)

Set Implicit Arguments.
Unset Strict Implicit.
Set Contextual Implicit.
Generalizable All Variables.

From Base Require Import Prelude Extraction.
From SimpleIO Require Import IO_Monad.
From CoqFFI Require Import Interface.

(** * Types *)

Axiom (fd : Type).

Extract Constant fd => "Examples.File.fd".

(** * Pure Functions *)

Axiom (fd_equal : fd -> fd -> bool).

Extract Constant fd_equal => "Examples.File.fd_equal".

(** * Impure Primitives *)

(** ** Monad *)

Class MonadFile (m : Type -> Type) : Type :=
  { openfile : bytestring -> m fd
  ; read_all : fd -> m bytestring
  ; write : fd -> bytestring -> m unit
  ; closefile : fd -> m unit
  }.

(** ** [IO] Instance *)

Axiom (io_openfile : bytestring -> IO fd).
Axiom (io_read_all : fd -> IO bytestring).
Axiom (io_write : fd -> bytestring -> IO unit).
Axiom (io_closefile : fd -> IO unit).

Extract Constant io_openfile =>
  "(fun x0 k__ -> k__ (Examples.File.openfile x0))".
Extract Constant io_read_all =>
  "(fun x0 k__ -> k__ (Examples.File.read_all x0))".
Extract Constant io_write =>
  "(fun x0 x1 k__ -> k__ (Examples.File.write x0 x1))".
Extract Constant io_closefile =>
  "(fun x0 k__ -> k__ (Examples.File.closefile x0))".

Instance MonadFile_IO : MonadFile IO :=
  { openfile := io_openfile
  ; read_all := io_read_all
  ; write := io_write
  ; closefile := io_closefile
  }.
```

See the `coqffi` man pages for more information on how to use it.
