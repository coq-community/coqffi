---
fullname: '`coqffi`'
shortname: coqffi
organization: coq-community
community: true
branch: main
travis: true
dune: true

synopsis: Tool for generating Coq FFI bindings to OCaml libraries

description: |-
  `coqffi` generates the necessary Coq boilerplate to use OCaml functions in a
  Coq development, and configures the Coq extraction mechanism accordingly.

authors:
- name: Thomas Letan
- name: Li-yao Xia
- name: Yann Régis-Gianas
- name: Yannick Zakowski

maintainers:
- name: Thomas Letan
  nickname: lthms

opam-file-maintainer: thomas.letan@ssi.gouv.fr

opam-file-version: dev

license:
  fullname: MIT License
  identifier: MIT

supported_coq_versions:
  text: 8.12 or later
  opam: '{(>= "8.12" & < "8.13~") | (= "dev")}'

supported_ocaml_versions:
    text: 4.08 or later
    opam: '{>= "4.08" & < "4.12~" }'

tested_coq_opam_versions:
- version: dev
- version: '8.12'

dependencies:
- opam:
    name: cmdliner
    version: '{>= "1.0.4"}'
  description: |-
    [Cmdliner](http://erratique.ch/software/cmdliner) 1.0.4 or later

namespace: CoqFFI

build: |-
 ## Building and installation instructions

 Make sure your OPAM installation points to the official Coq repository
 as documented [here](https://github.com/coq/opam-coq-archive), and
 then, the following should work:

 ``` shell
 git clone https://github.com/coq-community/coqffi.git
 cd coqffi
 opam install .
 ```

 Alternatively, you can install `coqffi`’s dependencies (as listed in
 the **Meta** section of the README), then build it.

 ```shell
 git clone https://github.com/coq-community/coqffi.git
 cd coqffi
 ./src-prepare.sh
 dune build -p coq-coqffi
 ```

keywords:
- name: foreign function interface
- name: extraction
- name: OCaml

categories:
- name: Miscellaneous/Coq Extensions

documentation: |-
  ## Example

  Suppose the following OCaml header file (`file.mli`) is given:

  ```ocaml
  type fd

  val fd_equal : fd -> fd -> bool

  val openfile : string -> fd [@@impure]
  val read_all : fd -> string [@@impure]
  val write : fd -> string -> unit [@@impure]
  val closefile : fd -> unit [@@impure]
  ```

  `coqffi` then generates the necessary Coq boilerplate to use these
  functions in a Coq development:

  ```coq
  (* This file has been generated by coqffi. *)

  Set Implicit Arguments.
  Unset Strict Implicit.
  Set Contextual Implicit.
  Generalizable All Variables.

  From Base Require Import Prelude Extraction.
  From SimpleIO Require Import IO_Monad.
  From CoqFFI Require Import Interface.

  (** * Types *)

  Axiom (fd : Type).

  Extract Constant fd => "Examples.File.fd".

  (** * Pure Functions *)

  Axiom (fd_equal : fd -> fd -> bool).

  Extract Constant fd_equal => "Examples.File.fd_equal".

  (** * Impure Primitives *)

  (** ** Monad *)

  Class MonadFile (m : Type -> Type) : Type :=
    { openfile : string -> m fd
    ; read_all : fd -> m string
    ; write : fd -> string -> m unit
    ; closefile : fd -> m unit
    }.

  (** ** [IO] Instance *)

  Axiom (io_openfile : string -> IO fd).
  Axiom (io_read_all : fd -> IO string).
  Axiom (io_write : fd -> string -> IO unit).
  Axiom (io_closefile : fd -> IO unit).

  Extract Constant io_openfile =>
    "(fun x0 k__ -> k__ (Examples.File.openfile x0))".
  Extract Constant io_read_all =>
    "(fun x0 k__ -> k__ (Examples.File.read_all x0))".
  Extract Constant io_write =>
    "(fun x0 x1 k__ -> k__ (Examples.File.write x0 x1))".
  Extract Constant io_closefile =>
    "(fun x0 k__ -> k__ (Examples.File.closefile x0))".

  Instance MonadFile_IO : MonadFile IO :=
    { openfile := io_openfile
    ; read_all := io_read_all
    ; write := io_write
    ; closefile := io_closefile
    }.
  ```

  The Coq modules outputted by `coqffi` may have dependencies, based
  on the features you have decided to use (*e.g.*, by default, the
  `simple-io` feature is enabled, leading generated module to depend
  on [`coq-simple-io`](https://github.com/Lysxia/coq-simple-io)).

  See the `coqffi` man pages for more information on how to use it.
---
