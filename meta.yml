---
fullname: coqffi
shortname: coqffi
organization: coq-community
community: true
travis: true
dune: true

synopsis: Tool for generating Coq FFI bindings to OCaml libraries

description: |-
  coqffi generates the necessary Coq boilerplate to use OCaml functions in a
  Coq development, and configures the Coq extraction mechanism accordingly.

authors:
- name: Thomas Letan
- name: Li-yao Xia
- name: Yann RÃ©gis-Gianas
- name: Yannick Zakowski

maintainers:
- name: Thomas Letan
  nickname: lthms

opam-file-maintainer: thomas.letan@ssi.gouv.fr

opam-file-version: dev

license:
  fullname: MIT License
  identifier: MIT

supported_coq_versions:
  text: 8.12 or later
  opam: '{(>= "8.12" & < "8.13~") | (= "dev")}'

supported_ocaml_versions:
    text: '4.10'
    opam: '{>= "4.10.0" & < "4.11~"}'

tested_coq_opam_versions:
- version: dev
- version: '8.12'

dependencies:
- opam:
    name: coq-ext-lib
    version: '{>= "0.11.2"}'
  description: |-
    [coq-ext-lib](https://github.com/coq-community/coq-ext-lib) 0.11.2 or later
- opam:
    name: coq-simple-io
    version: '{>= "1.3.0"}'
  description: |-
    [Coq Simple IO](https://github.com/Lysxia/coq-simple-io) 1.3.0 or later
- opam:
    name: cmdliner
    version: '{>= "1.0.4"}'
  description: |-
    [Cmdliner](http://erratique.ch/software/cmdliner) 1.0.4 or later

namespace: CoqFFI

build: |-
 ## Building and installation instructions

  ``` shell
  git clone https://github.com/coq-community/coqffi.git
  cd coqffi
  dune build -p coq-coqffi
  dune install
  ```

keywords:
- name: foreign function interface
- name: extraction
- name: OCaml

categories:
- name: Miscellaneous/Coq Extensions

documentation: |-
  ## Example

  Suppose the following OCaml header file (`file.mli`) is given:

  ```ocaml
  open Coqbase
  
  type fd
  
  val fd_equal : fd -> fd -> bool
  
  val openfile : Bytestring.t -> fd [@@impure]
  val read_all : fd -> Bytestring.t [@@impure]
  val write : fd -> Bytestring.t -> unit [@@impure]
  val closefile : fd -> unit [@@impure]
  ```
  
  `coqffi` then generates the necessary Coq boilerplate to use these
  functions in a Coq development:
  
  ```coq
  (* This file has been generated by coqffi. *)
  
  Set Implicit Arguments.
  Unset Strict Implicit.
  Set Contextual Implicit.
  Generalizable All Variables.
  
  From Base Require Import Prelude Extraction.
  From SimpleIO Require Import IO_Monad.
  From CoqFFI Require Import Interface.
  
  (** * Types *)
  
  Axiom (fd : Type).
  
  Extract Constant fd => "Examples.File.fd".
  
  (** * Pure Functions *)
  
  Axiom (fd_equal : fd -> fd -> bool).
  
  Extract Constant fd_equal => "Examples.File.fd_equal".
  
  (** * Impure Primitives *)
  
  (** ** Monad *)
  
  Class MonadFile (m : Type -> Type) : Type :=
    { openfile : bytestring -> m fd
    ; read_all : fd -> m bytestring
    ; write : fd -> bytestring -> m unit
    ; closefile : fd -> m unit
    }.
  
  (** ** [IO] Instance *)
  
  Axiom (io_openfile : bytestring -> IO fd).
  Axiom (io_read_all : fd -> IO bytestring).
  Axiom (io_write : fd -> bytestring -> IO unit).
  Axiom (io_closefile : fd -> IO unit).
  
  Extract Constant io_openfile =>
    "(fun x0 k__ -> k__ (Examples.File.openfile x0))".
  Extract Constant io_read_all =>
    "(fun x0 k__ -> k__ (Examples.File.read_all x0))".
  Extract Constant io_write =>
    "(fun x0 x1 k__ -> k__ (Examples.File.write x0 x1))".
  Extract Constant io_closefile =>
    "(fun x0 k__ -> k__ (Examples.File.closefile x0))".
  
  Instance MonadFile_IO : MonadFile IO :=
    { openfile := io_openfile
    ; read_all := io_read_all
    ; write := io_write
    ; closefile := io_closefile
    }.
  ```

  See the `coqffi` man pages for more information on how to use it.
---
